{-# LANGUAGE ScopedTypeVariables #-}    -- Allows type annotations on variables
                                        -- in do-notation
module TypeCheck where

import qualified Data.Set as S
import qualified Data.Map as M
import Control.Monad (foldM)

import Util
import Syntax

import Debug.Trace (traceShowId)

-----------------------
-- Environment types --
-----------------------

type Env = M.Map Name Type

-- Convert a TCDec into an Env containing type mappings for the functions
-- in the typeclass declaration
envFromTCDec :: TCDec -> Env
envFromTCDec (TCDec classN memberN funcs) =
    M.map (TQuant memberN (S.singleton classN)) funcs

----------------------
-- Constraint types --
----------------------

type Constraint = (Type, Type)

----------------------------------
-- Type checking implementation --
----------------------------------

type TypeSub = NameGen -> Type -> Result (Type, NameGen)

typeSubIdentity :: TypeSub
typeSubIdentity gen t = return (t, gen)

unify :: NameGen -> S.Set Constraint -> Result (TypeSub, NameGen)
unify gen constrs = if null constrs then return (typeSubIdentity, gen) else
    let (next, rest) = S.deleteFindMin constrs in case traceShowId next of

        (ty1, ty2) | ty1 == ty2 -> unify gen rest

        (TVar x _, ty) | S.notMember x $ frees ty -> handleVar x ty gen rest
        (ty, TVar x _) | S.notMember x $ frees ty -> handleVar x ty gen rest

        (TFunc a1 b1, TFunc a2 b2) -> unify gen $
            S.insert (a1, a2) $
            S.insert (b1, b2) $ rest

        (TProd a1 b1, TProd a2 b2) -> unify gen $
            S.insert (a1, a2) $
            S.insert (b1, b2) $ rest

        (TQuant _ _ _, _) -> Error "Implementation error - unremoved TQuant"
        (_, TQuant _ _ _) -> Error "Implementation error - unremoved TQuant"

        (ty1, ty2) -> Error $ "Unsatisfiable type constraint found: " ++
            show ty1 ++ " == " ++ show ty2

    where

        handleVar :: Name -> Type
                  -> NameGen -> S.Set Constraint -> Result (TypeSub, NameGen)
        handleVar x ty gen rest = let
            (subbedRest, gen') = foldl
                (\(cs, gen) c -> let
                        (c', gen') = constrSub gen x ty c
                        in (c' : cs, gen'))
                ([], gen)
                (S.toList rest)
            in do
                (unifyRest, gen'') <- unify gen' $ S.fromList subbedRest
                return $ (\gen body -> do
                        (body', gen') <- unifyRest gen body
                        return $ typeSubst x ty body' gen'
                    , gen'')

        constrSub :: NameGen -> Name -> Type -> Constraint ->
            (Constraint, NameGen)
        constrSub gen x ty (t1, t2) = let
            (t1', gen' ) = typeSubst x ty t1 gen
            (t2', gen'') = typeSubst x ty t2 gen'
            in ((t1', t2'), gen'')

type ConstraintGenResult a = Result (a, S.Set Constraint, NameGen)
type ConstraintGen a b = Env -> NameGen -> a -> ConstraintGenResult b

-- Do successive constraint generation operations, passing the NameGen along
-- properly, collecting the resulting types in a list and the constraints
-- generated by each operation in a single set.
foldCG :: ConstraintGen a b -> ConstraintGen [a] [b]
foldCG cg env gen = foldM (\(bs, constraints, gen) a -> do
    (b, constraintsA, gen') <- cg env gen a
    return (b : bs, S.union constraints constraintsA, gen')
    ) ([], S.empty, gen)

constraintsProg :: ConstraintGen Prog Type
constraintsProg env gen prog = let

    allInClassFuncNames :: [Name]
    allInClassFuncNames = concatMap (M.keys . functions) $ getTCDecs prog

    hasDuplicateInClassFuncNames :: Bool
    hasDuplicateInClassFuncNames =
        S.size (S.fromList allInClassFuncNames) < length allInClassFuncNames

    in if hasDuplicateInClassFuncNames then
        Error "Conflicting function definitions in typeclass declarations"
    else let

    envBindingsFromTCDecs :: Env
    envBindingsFromTCDecs = M.unions $ map envFromTCDec $ getTCDecs prog

    fnDecs :: [FNDec]
    fnDecs = getFNDecs prog

    fnNames :: [Name]
    fnNames = map fnName fnDecs

    hasDuplicateFuncNames :: Bool
    hasDuplicateFuncNames = S.size (S.fromList fnNames) < length fnNames

    in if hasDuplicateFuncNames then
        Error "Conflicting function definitions at top level"
    else let

    tVarNamesForFuncs :: [Name]
    gen' :: NameGen
    (tVarNamesForFuncs, gen') = genNNames (length fnDecs) gen

    envBindingsFromFNDecs :: Env
    envBindingsFromFNDecs =
        M.fromList $ zip fnNames $ map tVar tVarNamesForFuncs

    completeEnv :: Env
    completeEnv = M.union envBindingsFromFNDecs envBindingsFromTCDecs

    in do

    (_, functionConstraints :: S.Set Constraint, gen'' :: NameGen) <-
        foldCG constraintsFNDec completeEnv gen' fnDecs

    tiFuncs :: [FNDec] <- tiDecsAsFuncs prog

    (_, witnessConstraints :: S.Set Constraint, gen''' :: NameGen) <-
        foldCG constraintsFNDec completeEnv gen'' tiFuncs

    (mainType :: Type, mainConstraints :: S.Set Constraint,
        gen'''' :: NameGen) <- constraintsExp completeEnv gen''' (getMain prog)

    return ( mainType
           , S.unions [ functionConstraints
                      , witnessConstraints
                      , mainConstraints
                      ]
           , gen''''
           )

-- The given function expects a binding for its own name already in the Env
-- via a fresh type variable. constraintsProg adds this.
constraintsFNDec :: ConstraintGen FNDec ()
constraintsFNDec env gen (FNDec n ty args body) = let
    (argNames, gen') = genNNames (length args) gen
    envWithAll = M.unionWith (\_ x -> x) env $
        M.fromList $ zip args $ map tVar argNames 
    in do
    tyThis <- env ? n
    (tyBody, conBody, gen'') <- constraintsExp envWithAll gen' body
    return ((), S.insert (ty, tyThis) conBody, gen'')

constraintsExp :: Env -> NameGen -> Exp ->
    Result (Type, S.Set Constraint, NameGen)
constraintsExp env gen exp = case exp of
    App f a -> do
        let (newName, newGen) = genName gen
        let tyR = tVar newName
        (tyF, conF, genAfterF) <- constraintsExp env newGen f
        (tyA, conA, genAfterA) <- constraintsExp env genAfterF a
        let conAll = (tyF, TFunc tyA tyR) `S.insert` conF `S.union` conA
        return (tyR, conAll, newGen)
    Let n x y -> do
        (tyX, conX, genAfterX) <- constraintsExp env gen x
        (tyY, conY, genAfterY) <- constraintsExp (env += (n, tyX)) genAfterX y
        return (tyY, conX `S.union` conY, genAfterY)
    Lam n x -> do
        let (newName, newGen) = genName gen
        (tyX, conX, genAfterX) <-
            constraintsExp (env += (n, tVar newName)) newGen x
        return (TFunc (tVar newName) tyX, conX, genAfterX)
    Var x -> do
        tyX <- env ? x
        return (tyX, S.empty, gen)
    Const _ -> return (TInt, S.empty, gen)
    Prod e f -> do
        (tyE, conE, genAfterE) <- constraintsExp env gen e
        (tyF, conF, genAfterF) <- constraintsExp env genAfterE f
        return (TProd tyE tyF, conE `S.union` conF, genAfterF)
    Fst -> return (tForAll ["a", "b"] $
        TFunc (TProd (tVar "a") (tVar "b")) $ tVar "a", S.empty, gen)
    Snd -> return (tForAll ["a", "b"] $
        TFunc (TProd (tVar "a") (tVar "b")) $ tVar "b", S.empty, gen)
    Add -> return (TFunc TInt $ TFunc TInt TInt, S.empty, gen)
    Sub -> return (TFunc TInt $ TFunc TInt TInt, S.empty, gen)

dequantify :: NameGen -> Type -> (Type, NameGen)
dequantify gen ty = case ty of
    TProd a b -> let
        (a', gen' ) = dequantify gen  a
        (b', gen'') = dequantify gen' b
        in (TProd a' b', gen'')
    TFunc a b -> let
        (a', gen' ) = dequantify gen  a
        (b', gen'') = dequantify gen' b
        in (TFunc a' b', gen'')
    TQuant x s a -> let
        (fresh, gen') = genName gen
        (a', gen''  ) = typeSubst x (TVar fresh s) a gen' 
        in dequantify gen'' a'
    TInt -> (TInt, gen)
    TVar x cs -> (TVar x cs, gen)

{- SOME NOTES FROM 'IMPLEMENTING TYPE CLASSES' - PETERSON, JONES, SECTION 5

We will separate the issues of type inference, in which each program expression is assigned a (possibly overloaded) type, and dictionary conversion, in which the program code is transformed to explicitly extract method functions from dictionaries.

The use and implementation of ML style type inference is well documented and we will not repeat this here. Instead, we concentrate on the relatively minor changes that are needed to extend ML style type inference with support for type classes.

As in ordinary ML typechecking, type variables and unification playa central role. Type variables are initially unbound, corresponding to 'unknown' types. As type checking proceeds, various constraints on the values that can be as-signed to type variables are exposed, for example by ensuring that the argument type of a given function is the same as the type of the value to which it is actually applied. Thett con-straints are solved by instantiating unbound type variables to more accurate types. Type classes require an additional field in each uninstantiated type variable: the context, a set (represented by a list) of classes.

Unification is affected in a very simple way: when a type variable is instantiated, its class constraints must be passed on to the instantiated value. If this is another type variable, its context is augmented, using set union, by the context of the instantiated variable. When a context is passed on to a type constructor context reduction is required. Context reduction uses the instance declarations in the static type environment to propagate all class constraints to type variables.

The type constructor being reduced by context reduction must be an instance of the reducing class. If not, type checking fails with an error that an attempt has been made to use an overloaded operator at a type that is not an instance of the corresponding class. If an instance declaration is found linking the data type and the class, the context of the instance declaration propagates to the type constructor arguments. This process continues until contexts have been propagated exclusively to type variables.

As an example, consider the unification of 'Eq a => a', a type variable with an 'Eq' context, and the type '[Integer]'. The type variable is instantiated to [Integer]. Before context reduction, the resulting type is 'Eq [Integer] => [Integer]'. The instance declaration for class 'Eq' over the list data type exists (otherwise a type error occurs) and propagates the context 'Eq' to the argument to the list type constructor. This leads to the type 'Eq Integer => [Integer]'. Now we can see that the program must also include an instance decimation that makes 'Integer' an instance of the class 'Eq'. Assuming that this is true, and since the 'Integer' type constructor does not take any arguments, no further constraints can exist leaving only '[Integer]' as the resulting type. Note, however, that the unification would have failed if the required instance declarations were not found in the static type environment. By a similar process, unification of 'Eq a => a' and '[b]' would yield the type 'Eq b => [b]'. Here, contexts remain attached to the resulting type variables. The following code implements type variable instantiation in the presence of type classes. Each type variable has a value field which is either null (uninstantiated) or contains an instaniated type. The context field is a list of classes attached to uninstantiated type variables. The findInstanceContext function searches the static type environment for an instance with the selected class and data type. If not is found this function signals a type error. It returns a list of contexts, one for each argument to the data type. 

instantiateTyvar(tyvar, type)
	tyvar.value := type
	propagateClasses(tyvar.context, type) 

propagateClasses(classes,type)
	if tyvar(type)
		then type.context := union(classes,type.context)
		else for each c in classes
			propagateClassTycon(c,type) 

propagateClassTycon(class,type)
	s = findInstanceContext(type.tycon, class)
	for each classSet in s, typeArg in tycon.args
		propagateClasses(classSet, typeArg) 

One other minor change to ML type inference is required. When a letrec is typechecked all variables defined by the letrec share a common context. This will be discussed in Section 8.3.

It is worth emphasizing that context reduction is the only significant change to the ML type inference process neces-sary to infer correct typings for Haskell programs involving type classes. On the other hand, dictionary conversion, as described in the following section (or some similar process), must be carried out to implement overloading in the final executable version of the type checked program. 
-}
