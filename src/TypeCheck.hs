{-# LANGUAGE ScopedTypeVariables #-}    -- Allows type annotations on variables
                                        -- in do-notation
module TypeCheck where

import qualified Data.Set as S
import qualified Data.Map as M
import Control.Monad (foldM)

import Util
import Syntax

import Debug.Trace (traceShowId)

-----------------------
-- Environment types --
-----------------------

type Env = M.Map Name Type

-- Convert a TCDec into an Env containing type mappings for the functions
-- in the typeclass declaration
envFromTCDec :: NameGen -> TCDec -> (Env, NameGen)
envFromTCDec gen (TCDec classN memberN funcs) = let
    (funcs', gen') =
        foldl (\(done, gen) (n, ty) -> let
            (ty', gen') =
                dequantify gen (TQuant memberN (S.singleton classN) ty)
            in ((n, ty') : done, gen')
        ) ([], gen) $
        M.toList funcs
    in (M.fromList funcs', gen')

envFromTCDecs :: NameGen -> [TCDec] -> (Env, NameGen)
envFromTCDecs gen = foldl (\(env, gen) dec -> let
    (envD, gen') = envFromTCDec gen dec
    in (M.union env envD, gen')
    ) (M.empty, gen)

----------------------
-- Constraint types --
----------------------

type Constraint = (Type, Type)

----------------------------------
-- Type checking implementation --
----------------------------------

-- Implementation that serves the same purpose as propagateClasses from
-- 'Implementing Type Classes - Peterson, Jones'. This implementation is simpler
-- because we do not allow for instances of the form
-- 'instance C t => C (M t) where' i.e. we do not allow instance contexts.
-- The Peterson-Jones algorithm has extra machinery to handle contexts.
propagateClasses :: S.Set (Name, Type) -> S.Set Name -> Type -> Result Type
propagateClasses instances classes ty = case ty of
    TVar x cs    -> return $ TVar x (S.union cs classes)
    TQuant x s a -> Error "Implementation error - unremoved TQuant"
    other        -> let
        noInstanceFound :: [Name] =
            filter (\clas -> S.notMember (clas, ty) instances) $
            S.toList classes
        in if null noInstanceFound then
            return ty
        else
            Error $ "No instance for " ++ head noInstanceFound ++ " " ++ show ty

type TypeSub = NameGen -> Type -> Result (Type, NameGen)

typeSubIdentity :: TypeSub
typeSubIdentity gen t = return (t, gen)

unify :: S.Set (Name, Type) -> NameGen -> S.Set Constraint
      -> Result (TypeSub, NameGen)
unify classEnv gen constrs =
    if null constrs then return (typeSubIdentity, gen) else
        let (next, rest) = S.deleteFindMin constrs in case traceShowId next of

            (ty1, ty2) | ty1 == ty2 -> unify classEnv gen rest

            (TVar x cs, ty) | S.notMember x $ frees ty ->
                handleVar x cs ty classEnv gen rest
            (ty, TVar x cs) | S.notMember x $ frees ty ->
                handleVar x cs ty classEnv gen rest

            (TFunc a1 b1, TFunc a2 b2) -> unify classEnv gen $
                S.insert (a1, a2) $
                S.insert (b1, b2) $ rest

            (TProd a1 b1, TProd a2 b2) -> unify classEnv gen $
                S.insert (a1, a2) $
                S.insert (b1, b2) $ rest

            (TQuant _ _ _, _) -> Error "Implementation error - unremoved TQuant"
            (_, TQuant _ _ _) -> Error "Implementation error - unremoved TQuant"

            (ty1, ty2) -> Error $ "Unsatisfiable type constraint found: " ++
                show ty1 ++ " == " ++ show ty2

    where

        handleVar :: Name -> S.Set Name -> Type -> S.Set (Name, Type)
                  -> NameGen -> S.Set Constraint -> Result (TypeSub, NameGen)
        handleVar x cs ty classEnv gen rest = do
            (subbedRest, gen') <- foldM
                (\(done, gen) c -> do
                    (c', gen') <- constrSub gen x cs ty classEnv c
                    return (c' : done, gen'))
                ([], gen)
                (S.toList rest)
            (unifyRest, gen'') <- unify classEnv gen' $ S.fromList subbedRest
            return $ (\gen body -> do
                    (body', gen') <- unifyRest gen body
                    return $ typeSubst x ty body' gen'
                , gen'')

        constrSub :: NameGen -> Name -> S.Set Name -> Type -> S.Set (Name, Type)
                  -> Constraint -> Result (Constraint, NameGen)
        constrSub gen x cs ty classEnv (t1, t2) = let
            (t1', gen' ) = typeSubst x ty t1 gen
            (t2', gen'') = typeSubst x ty t2 gen'
            in do
            t1propagated <- propagateClasses classEnv cs t1'
            t2propagated <- propagateClasses classEnv cs t2'
            return ((t1propagated, t2propagated), gen'')

type ConstraintGenResult a = Result (a, S.Set Constraint, NameGen)
type ConstraintGen a b = Env -> NameGen -> a -> ConstraintGenResult b

-- Do successive constraint generation operations, passing the NameGen along
-- properly, collecting the resulting types in a list and the constraints
-- generated by each operation in a single set.
foldCG :: ConstraintGen a b -> ConstraintGen [a] [b]
foldCG cg env gen = foldM (\(bs, constraints, gen) a -> do
    (b, constraintsA, gen') <- cg env gen a
    return (b : bs, S.union constraints constraintsA, gen')
    ) ([], S.empty, gen)

constraintsProg :: ConstraintGen Prog Type
constraintsProg env gen prog = let

    allInClassFuncNames :: [Name]
    allInClassFuncNames = concatMap (M.keys . functions) $ getTCDecs prog

    hasDuplicateInClassFuncNames :: Bool
    hasDuplicateInClassFuncNames =
        S.size (S.fromList allInClassFuncNames) < length allInClassFuncNames

    in if hasDuplicateInClassFuncNames then
        Error "Conflicting function definitions in typeclass declarations"
    else let

    envBindingsFromTCDecs :: Env
    gen' :: NameGen
    (envBindingsFromTCDecs, gen') = envFromTCDecs gen $ getTCDecs prog

    fnDecs :: [FNDec]
    fnDecs = getFNDecs prog

    fnNames :: [Name]
    fnNames = map fnName fnDecs

    hasDuplicateFuncNames :: Bool
    hasDuplicateFuncNames = S.size (S.fromList fnNames) < length fnNames

    in if hasDuplicateFuncNames then
        Error "Conflicting function definitions at top level"
    else let

    tVarNamesForFuncs :: [Name]
    gen'' :: NameGen
    (tVarNamesForFuncs, gen'') = genNNames (length fnDecs) gen'

    envBindingsFromFNDecs :: Env
    envBindingsFromFNDecs =
        M.fromList $ zip fnNames $ map tVar tVarNamesForFuncs

    completeEnv :: Env
    completeEnv = M.union envBindingsFromFNDecs envBindingsFromTCDecs

    in do

    (_, functionConstraints :: S.Set Constraint, gen''' :: NameGen) <-
        foldCG constraintsFNDec completeEnv gen'' fnDecs

    tiFuncs :: [FNDec] <- tiDecsAsFuncs prog

    (_, witnessConstraints :: S.Set Constraint, gen'''' :: NameGen) <-
        foldCG constraintsFNDec completeEnv gen''' tiFuncs

    (mainType :: Type, mainConstraints :: S.Set Constraint,
        gen''''' :: NameGen) <- constraintsExp completeEnv gen'''' (getMain prog)

    return ( mainType
           , S.unions [ functionConstraints
                      , witnessConstraints
                      , mainConstraints
                      ]
           , gen'''''
           )

-- Generate a set of all (class name, type) instance declarations that exist in
-- the program. Fails when an instance has a class that is not declared.
genInstanceDecs :: Prog -> Result (S.Set (Name, Type))
genInstanceDecs prog = let
    classes :: S.Set Name = S.fromList $ map classNameTC $ getTCDecs prog
    instances :: S.Set (Name, Type) =
        S.fromList $ map (\i -> (classNameTI i, memberType i)) $ getTIDecs prog
    in
        if (S.map fst instances) `S.isSubsetOf` classes then
            return instances
        else
            Error $ "Instance declarations with no corresponding class " ++
                "exist: " ++
                showAList ", " (S.toList ((S.map fst instances) S.\\ classes))

-- The given function expects a binding for its own name already in the Env
-- via a fresh type variable. constraintsProg adds this.
constraintsFNDec :: ConstraintGen FNDec ()
constraintsFNDec env gen (FNDec n ty args body) = let
    (argNames, gen') = genNNames (length args) gen
    envWithAll = M.unionWith (\_ x -> x) env $
        M.fromList $ zip args $ map tVar argNames 
    in do
    tyThis <- env ? n
    (tyBody, conBody, gen'') <- constraintsExp envWithAll gen' body
    return ((), S.insert (ty, tyThis) conBody, gen'')

constraintsExp :: Env -> NameGen -> Exp ->
    Result (Type, S.Set Constraint, NameGen)
constraintsExp env gen exp = case exp of
    App f a -> do
        let (newName, newGen) = genName gen
        let tyR = tVar newName
        (tyF, conF, genAfterF) <- constraintsExp env newGen f
        (tyA, conA, genAfterA) <- constraintsExp env genAfterF a
        let conAll = (tyF, TFunc tyA tyR) `S.insert` conF `S.union` conA
        return (tyR, conAll, newGen)
    Let n x y -> do
        (tyX, conX, genAfterX) <- constraintsExp env gen x
        (tyY, conY, genAfterY) <- constraintsExp (env += (n, tyX)) genAfterX y
        return (tyY, conX `S.union` conY, genAfterY)
    Lam n x -> do
        let (newName, newGen) = genName gen
        (tyX, conX, genAfterX) <-
            constraintsExp (env += (n, tVar newName)) newGen x
        return (TFunc (tVar newName) tyX, conX, genAfterX)
    Var x -> do
        tyX <- env ? x
        return (tyX, S.empty, gen)
    Const _ -> return (TInt, S.empty, gen)
    Prod e f -> do
        (tyE, conE, genAfterE) <- constraintsExp env gen e
        (tyF, conF, genAfterF) <- constraintsExp env genAfterE f
        return (TProd tyE tyF, conE `S.union` conF, genAfterF)
    Fst -> let
        (ty, gen') = dequantify gen (
            tForAll ["a", "b"] $ TFunc (TProd (tVar "a") (tVar "b")) $ tVar "a")
        in return (ty, S.empty, gen')
    Snd -> let
        (ty, gen') = dequantify gen (
            tForAll ["a", "b"] $ TFunc (TProd (tVar "a") (tVar "b")) $ tVar "b")
        in return (ty, S.empty, gen')
    Add -> return (TFunc TInt $ TFunc TInt TInt, S.empty, gen)
    Sub -> return (TFunc TInt $ TFunc TInt TInt, S.empty, gen)

dequantify :: NameGen -> Type -> (Type, NameGen)
dequantify gen ty = case ty of
    TProd a b -> let
        (a', gen' ) = dequantify gen  a
        (b', gen'') = dequantify gen' b
        in (TProd a' b', gen'')
    TFunc a b -> let
        (a', gen' ) = dequantify gen  a
        (b', gen'') = dequantify gen' b
        in (TFunc a' b', gen'')
    TQuant x s a -> let
        (fresh, gen') = genName gen
        (a', gen''  ) = typeSubst x (TVar fresh s) a gen' 
        in dequantify gen'' a'
    TInt -> (TInt, gen)
    TVar x cs -> (TVar x cs, gen)
